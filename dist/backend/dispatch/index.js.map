{"version":3,"sources":["../../../src/backend/dispatch/index.ts"],"names":["unsafeGlobal","global","WebSocket","require","PlatformEvents","Dispatch","config","axios","get","projectId","data","Promise","resolve","ws","options","projectToken","shardName","maxConnectionsPerShard","authorization","params","Object","keys","reduce","acc","cur","push","encodeURIComponent","url","join","authToken","Sockette","timeout","maxAttempts","onmessage","e","handleMessage","onreconnect","handleReconnect","onmaximum","handleMaximum","onclose","handleClose","onerror","handleError","JSON","parse","eventName","latencyMs","payload","CONNECTED","initialConnection","isConnected","identify","clientId","eventHandlers","forEach","handler","callback","messageQueue","send","console","error","handlerId","id","filter","emitEvent","IDENTIFY","token","recipients","message","stringify","length","Error","close","Base"],"mappings":"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","sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport Sockette from 'sockette';\nimport axios from 'axios';\nimport { Base, BackendConfigurationInput } from '../base';\n\nconst unsafeGlobal: any = global;\nunsafeGlobal.WebSocket = require('isomorphic-ws');\n\n/**\n * Configuration options for a new connection.\n */\nexport interface DispatchConfigurationInput {\n  /** Name of the dispatch shard to use. If not specified, the client is added to a shard automatically. */\n  shardName?: string | null;\n  /** Total clients to allow on a shard before it is full (defaults to 100). When a shard is full, new clients are added to a new shard unless a different shard is explicitly set. */\n  maxConnectionsPerShard?: number;\n  /** Short-lived user token that identifies the client, so the server and other connected clients can send it secure messages. If the user token is not included, you can [[identify | identify the client]] after it is connected. */\n  authorization?: string;\n}\n\n/**\n * Defines a DispatchOptions interface.\n */\ninterface DispatchOptions {\n  projectId: string;\n  projectToken?: string;\n  shardName?: string | null;\n  maxConnectionsPerShard?: number;\n  authorization?: string;\n  [index: string]: any;\n}\n\n/**\n * Defines constants for Koji platform events.\n */\nexport enum PlatformEvents {\n  CONNECTED = '@@KOJI_DISPATCH/CONNECTED',\n  CONNECTED_CLIENTS_CHANGED = '@@KOJI_DISPATCH/CONNECTED_CLIENTS_CHANGED',\n  IDENTIFY = '@@KOJI_DISPATCH/IDENTIFY',\n  SET_USER_INFO = '@@KOJI_DISPATCH/SET_USER_INFO',\n}\n\n/**\n * Defines a MessageHandler interface.\n */\nexport interface MessageHandler {\n  id: string;\n  eventName: string;\n  callback: MessageHandlerCallback;\n}\n\n/**\n * Additional data attached to a dispatch message.\n */\nexport interface DispatchMessageMetadata {\n  /** Message latency in milliseconds. */\n  latencyMs: number;\n}\n\nexport type MessageHandlerCallback =\n/**\n * Function to handle a dispatch event. Invoked by the [[on]] listener.\n *\n * @param payload   Data payload sent with the fired event.\n * @param metadata  Object containing additional information about the event, including the message latency in milliseconds.\n */\n(payload: { [index: string]: any }, metadata: DispatchMessageMetadata) => void;\n\n/**\n * Information about a dispatch shard.\n */\nexport interface ShardInfo {\n  /** Name of the dispatch shard. */\n  shardName: string;\n  /** Number of clients currently connected to the dispatch shard. */\n  numConnectedClients: number;\n}\n\n/**\n * Connection details for a client. Returned when the client [[connect | connects to a dispatch shard]].\n */\nexport interface ConnectionInfo {\n  /** ID of the connected client. */\n  clientId?: string;\n  /** Name of the dispatch shard that the client is connected to. */\n  shardName: string;\n}\n\n/**\n * Implements a real-time messaging dispatch system for the backend of your Koji app.\n */\nexport class Dispatch extends Base {\n  private authToken?: string;\n  private initialConnection: boolean = false;\n  private isConnected: boolean = false;\n  private eventHandlers: MessageHandler[] = [];\n  private messageQueue: string[] = [];\n  private ws: Sockette | null = null;\n\n  /**\n   * Instantiates the Dispatch class.\n   *\n   * @param   config\n   *\n   * @example\n   * ```javascript\n   * const dispatch = new KojiBackend.Dispatch({ res });\n   * ```\n   */\n  public constructor(config: BackendConfigurationInput) {\n    super(config);\n  }\n\n  /**\n   * Gets information about the active dispatch shards.\n   *\n   * @return        Array of objects containing information about the dispatch shards.\n   *\n   * @example\n   * ```javascript\n   * const shardInfo = await dispatch.info();\n   * ```\n   */\n  public async info(): Promise<ShardInfo> {\n    const { data } = await axios.get(`https://dispatch-info.api.gokoji.com/info/${this.projectId}`);\n    return (data || [])[0];\n  }\n\n  /**\n   * Connects a client to a dispatch shard.\n   *\n   * @param config    Configuration options for the connection.\n   *\n   * @return          Connection details, including the client ID and shard name.\n   *\n   * @example\n   * ```javascript\n   * const myInfo = await dispatch.connect({\n   *  maxConnectionsPerShard: '25',\n   *  authorization: token\n   * });\n   * ```\n   */\n  public async connect(config: DispatchConfigurationInput = {}): Promise<ConnectionInfo> {\n    return new Promise((resolve) => {\n      if (this.ws) {\n        return;\n      }\n\n      const options: DispatchOptions = {\n        projectId: this.projectId,\n        projectToken: this.projectToken,\n        shardName: config.shardName,\n        maxConnectionsPerShard: config.maxConnectionsPerShard || 100,\n        authorization: config.authorization,\n      };\n\n      const params: string[] = Object.keys(options).reduce((acc: string[], cur) => {\n        if (options[cur]) {\n          acc.push(`${cur}=${encodeURIComponent(options[cur])}`);\n        }\n        return acc;\n      }, []);\n\n      const url = `wss://dispatch.api.gokoji.com?${params.join('&')}`;\n\n      this.authToken = config.authorization;\n\n      // Create a socket connection to the dispatch server\n      this.ws = new Sockette(url, {\n        timeout: 5e3,\n        maxAttempts: 10,\n        onmessage: (e) => this.handleMessage(e, resolve),\n        onreconnect: () => this.handleReconnect(),\n        onmaximum: () => this.handleMaximum(),\n        onclose: () => this.handleClose(),\n        onerror: (e) => this.handleError(e),\n      });\n    });\n  }\n\n  /**\n   * Handles a message event.\n   *\n   * @param     data        JSON object containing eventName, latencyMS, and payload.\n   * @param     eventName   PlatformEvents enum value.\n   * @param     latencyMS   Latency in milliseconds.\n   * @param     payload     Client object.\n   *\n   * @example\n   * ```javascript\n   * dispatch.handleMessage(PlatformEvents.CONNECTED, 1000, client);\n   * ```\n   */\n  private handleMessage({ data }: { data: string }, resolve: Function) {\n    const { eventName, latencyMs, payload } = JSON.parse(data || '{}');\n\n    if (eventName === PlatformEvents.CONNECTED) {\n      this.initialConnection = true;\n      this.isConnected = true;\n      if (this.authToken) this.identify(this.authToken);\n      resolve({\n        clientId: payload.clientId,\n        shardName: payload.shardName,\n      });\n      return;\n    }\n\n    this.eventHandlers.forEach((handler) => {\n      if (eventName === handler.eventName) {\n        handler.callback(payload, { latencyMs });\n      }\n    });\n  }\n\n  /**\n   * Reconnects a shard.\n   *\n   * @example\n   * ```javascript\n   * dispatch.handleReconnect();\n   * ```\n   */\n  private handleReconnect() {\n    this.isConnected = true;\n    this.messageQueue = this.messageQueue.reduce((acc, cur) => {\n      if (this.ws) {\n        this.ws.send(cur);\n      }\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Handles maximum.\n   *\n   * @example\n   * ```javascript\n   * dispatch.handleMaximum();\n   * ```\n   */\n  private handleMaximum() {}\n\n  /**\n   * Cleans up when connection is closed.\n   *\n   * @example\n   * ```javascript\n   * dispatch.handleClose();\n   * ```\n   */\n  private handleClose() {\n    this.isConnected = false;\n  }\n\n  /**\n   * Prints error message to console.\n   *\n   * @param     e    Event that generated the error.\n   *\n   * @example\n   * ```javascript\n   * dispatch.handleError(e);\n   * ```\n   */\n  private handleError(e: Event) {\n    console.error('[Koji Dispatch] error', e);\n  }\n\n  /**\n   * Sets a listener for a specific event, and invokes a callback function when the event is dispatched over the shard.\n   *\n   * @param     eventName     Name of the event to subscribe to.\n   * @param     callback      Function to invoke when the event is fired.\n   *\n   * @return                  Function to unsubscribe from the event listener.\n   *\n   * @example\n   * ```javascript\n   * unsubscribeEvent = dispatch.on('eventName', callbackFunction);\n   * ```\n   */\n  public on(eventName: string, callback: MessageHandlerCallback): Function {\n    const handlerId = uuidv4();\n\n    this.eventHandlers.push({\n      id: handlerId,\n      eventName,\n      callback,\n    });\n\n    return () => {\n      this.eventHandlers = this.eventHandlers.filter(({ id }) => id !== handlerId);\n    };\n  }\n\n  /**\n   * Identifies a connected client, which enables the server and other connected clients to send it secure messages.\n   *\n   * @param     authToken     Short-lived user token for the connected client. To get a user token, use {@doclink core-frontend-identity#getToken | Identity.getToken}.\n   *\n   * @example\n   * ```javascript\n   * const authToken = await identity.getToken();\n   * dispatch.identify(authToken.token);\n   * ```\n   */\n  public identify(authToken: string) {\n    this.emitEvent(PlatformEvents.IDENTIFY, {\n      token: authToken,\n    });\n  }\n\n  /**\n   * Emits the named event to the specified recipients or to all clients.\n   *\n   * @param     eventName     Name of the event.\n   * @param     payload       Object of key-value pair data to send as a message payload.\n   * @param     recipients    List of clients to receive the event. If this parameter is not included, the event is sent to all clients on the current shard.\n   *\n   * @example\n   * ```javascript\n   * dispatch.emitEvent('myEvent', myDataPayload);\n   * ```\n   */\n  public emitEvent(eventName: string, payload: { [index: string]: any }, recipients?: string[]) {\n    const message = JSON.stringify({\n      eventName,\n      payload,\n      recipients,\n    });\n\n    // Discard a long message\n    if (message.length > 128e3) {\n      throw new Error('Message is too long to be sent through Koji Dispatch. Messages must be less than 128kb');\n    }\n\n    // Check instantiation\n    if (!this.initialConnection || !this.ws) {\n      throw new Error('Please make sure you have called and awaited `connect()` before attempting to send a message');\n    }\n\n    // If the connection has dropped, push the message into a queue\n    if (!this.isConnected) {\n      this.messageQueue.push(message);\n      return;\n    }\n\n    this.ws.send(message);\n  }\n\n  /**\n   * Disconnects the client from the dispatch shard.\n   *\n   * @example\n   * ```javascript\n   * dispatch.disconnect();\n   * ```\n   */\n  public disconnect() {\n    if (this.ws) this.ws.close();\n    this.ws = null;\n  }\n}\n"],"file":"index.js"}