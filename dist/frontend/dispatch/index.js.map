{"version":3,"sources":["../../../src/frontend/dispatch/index.ts"],"names":["unsafeGlobal","global","WebSocket","require","PlatformEvents","Dispatch","axios","get","projectId","data","config","Promise","resolve","ws","options","shardName","maxConnectionsPerShard","params","Object","keys","reduce","acc","cur","push","encodeURIComponent","url","join","authToken","authorization","Sockette","timeout","maxAttempts","onmessage","e","handleMessage","onreconnect","handleReconnect","onmaximum","handleMaximum","onclose","handleClose","onerror","handleError","JSON","parse","eventName","latencyMs","payload","console","log","CONNECTED","initialConnection","isConnected","identify","clientId","eventHandlers","forEach","handler","callback","messageQueue","send","error","handlerId","id","filter","userInfo","emitEvent","SET_USER_INFO","IDENTIFY","token","recipients","message","stringify","length","Error","close","dispatch"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA,IAAMA,YAAiB,GAAGC,MAA1B;AACAD,YAAY,CAACE,SAAb,GAAyBC,OAAO,CAAC,eAAD,CAAhC;IAgBYC,c;;;WAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;GAAAA,c,8BAAAA,c;;IAyBCC,Q;;;;;gEAI0B,K;0DACN,K;4DACW,E;2DACT,E;iDACH,I;;;;;;;;;;;;;;uBAGLC,kBAAMC,GAAN,qDAAuD,KAAKC,SAA5D,E;;;;AAAfC,gBAAAA,I,oBAAAA,I;iDACD,CAACA,IAAI,IAAI,EAAT,EAAa,CAAb,C;;;;;;;;;;;;;;;;;;iCAGWD,S,EAAmB;AACrC,WAAKA,SAAL,GAAiBA,SAAjB;AACD;;;;;;;;;;;;;AAEoBE,gBAAAA,M,8DAAqC,E;kDACjD,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC9B,sBAAI,KAAI,CAACC,EAAT,EAAa;AACX;AACD;;AAED,sBAAMC,OAAwB,GAAG;AAC/BN,oBAAAA,SAAS,EAAE,KAAI,CAACA,SADe;AAE/BO,oBAAAA,SAAS,EAAEL,MAAM,CAACK,SAFa;AAG/BC,oBAAAA,sBAAsB,EAAEN,MAAM,CAACM,sBAAP,IAAiC;AAH1B,mBAAjC;AAMA,sBAAMC,MAAgB,GAAGC,MAAM,CAACC,IAAP,CAAYL,OAAZ,EAAqBM,MAArB,CAA4B,UAACC,GAAD,EAAgBC,GAAhB,EAAwB;AAC3E,wBAAIR,OAAO,CAACQ,GAAD,CAAX,EAAkB;AAChBD,sBAAAA,GAAG,CAACE,IAAJ,WAAYD,GAAZ,cAAmBE,kBAAkB,CAACV,OAAO,CAACQ,GAAD,CAAR,CAArC;AACD;;AACD,2BAAOD,GAAP;AACD,mBALwB,EAKtB,EALsB,CAAzB;AAOA,sBAAMI,GAAG,2CAAoCR,MAAM,CAACS,IAAP,CAAY,GAAZ,CAApC,CAAT;AAEA,kBAAA,KAAI,CAACC,SAAL,GAAiBjB,MAAM,CAACkB,aAAxB,CApB8B,CAsB9B;;AACA,kBAAA,KAAI,CAACf,EAAL,GAAU,IAAIgB,oBAAJ,CAAaJ,GAAb,EAAkB;AAC1BK,oBAAAA,OAAO,EAAE,GADiB;AAE1BC,oBAAAA,WAAW,EAAE,EAFa;AAG1BC,oBAAAA,SAAS,EAAE,mBAACC,CAAD;AAAA,6BAAO,KAAI,CAACC,aAAL,CAAmBD,CAAnB,EAAsBrB,OAAtB,CAAP;AAAA,qBAHe;AAI1BuB,oBAAAA,WAAW,EAAE;AAAA,6BAAM,KAAI,CAACC,eAAL,EAAN;AAAA,qBAJa;AAK1BC,oBAAAA,SAAS,EAAE;AAAA,6BAAM,KAAI,CAACC,aAAL,EAAN;AAAA,qBALe;AAM1BC,oBAAAA,OAAO,EAAE,iBAACN,CAAD;AAAA,6BAAO,KAAI,CAACO,WAAL,CAAiBP,CAAjB,CAAP;AAAA,qBANiB;AAO1BQ,oBAAAA,OAAO,EAAE,iBAACR,CAAD;AAAA,6BAAO,KAAI,CAACS,WAAL,CAAiBT,CAAjB,CAAP;AAAA;AAPiB,mBAAlB,CAAV;AASD,iBAhCM,C;;;;;;;;;;;;;;;;;;wCAmCyCrB,O,EAAmB;AAAA,UAA7CH,IAA6C,QAA7CA,IAA6C;;AAAA,wBACzBkC,IAAI,CAACC,KAAL,CAAWnC,IAAI,IAAI,IAAnB,CADyB;AAAA,UAC3DoC,SAD2D,eAC3DA,SAD2D;AAAA,UAChDC,SADgD,eAChDA,SADgD;AAAA,UACrCC,OADqC,eACrCA,OADqC;;AAEnEC,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBxC,IAAvB;;AAEA,UAAIoC,SAAS,KAAKzC,cAAc,CAAC8C,SAAjC,EAA4C;AAC1C,aAAKC,iBAAL,GAAyB,IAAzB;AACA,aAAKC,WAAL,GAAmB,IAAnB;AACA,YAAI,KAAKzB,SAAT,EAAoB,KAAK0B,QAAL,CAAc,KAAK1B,SAAnB;AACpBf,QAAAA,OAAO,CAAC;AACN0C,UAAAA,QAAQ,EAAEP,OAAO,CAACO,QADZ;AAENvC,UAAAA,SAAS,EAAEgC,OAAO,CAAChC;AAFb,SAAD,CAAP;AAIA;AACD;;AAED,WAAKwC,aAAL,CAAmBC,OAAnB,CAA2B,UAACC,OAAD,EAAa;AACtC,YAAIZ,SAAS,KAAKY,OAAO,CAACZ,SAA1B,EAAqC;AACnCY,UAAAA,OAAO,CAACC,QAAR,CAAiBX,OAAjB,EAA0B;AAAED,YAAAA,SAAS,EAATA;AAAF,WAA1B;AACD;AACF,OAJD;AAKD;;;sCAEyB;AAAA;;AACxBE,MAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACA,WAAKG,WAAL,GAAmB,IAAnB;AACA,WAAKO,YAAL,GAAoB,KAAKA,YAAL,CAAkBvC,MAAlB,CAAyB,UAACC,GAAD,EAAMC,GAAN,EAAc;AACzD,YAAI,MAAI,CAACT,EAAT,EAAa;AACX,UAAA,MAAI,CAACA,EAAL,CAAQ+C,IAAR,CAAatC,GAAb;AACD;;AACD,eAAOD,GAAP;AACD,OALmB,EAKjB,EALiB,CAApB;AAMD;;;oCAEuB,CAAE;;;gCAENY,C,EAAU;AAC5Be,MAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBhB,CAArB;AACA,WAAKmB,WAAL,GAAmB,KAAnB;AACD;;;gCAEmBnB,C,EAAU;AAC5Be,MAAAA,OAAO,CAACa,KAAR,CAAc,uBAAd,EAAuC5B,CAAvC;AACD;;;uBAESY,S,EAAmBa,Q,EAA4C;AAAA;;AACvE,UAAMI,SAAS,GAAG,eAAlB;AAEA,WAAKP,aAAL,CAAmBhC,IAAnB,CAAwB;AACtBwC,QAAAA,EAAE,EAAED,SADkB;AAEtBjB,QAAAA,SAAS,EAATA,SAFsB;AAGtBa,QAAAA,QAAQ,EAARA;AAHsB,OAAxB;AAMA,aAAO,YAAM;AACX,QAAA,MAAI,CAACH,aAAL,GAAqB,MAAI,CAACA,aAAL,CAAmBS,MAAnB,CAA0B;AAAA,cAAGD,EAAH,SAAGA,EAAH;AAAA,iBAAYA,EAAE,KAAKD,SAAnB;AAAA,SAA1B,CAArB;AACD,OAFD;AAGD;;;gCAEkBG,Q,EAAoC;AACrD,WAAKC,SAAL,CAAe9D,cAAc,CAAC+D,aAA9B,EAA6CF,QAA7C;AACD;;;6BAEetC,S,EAAmB;AACjC,WAAKuC,SAAL,CAAe9D,cAAc,CAACgE,QAA9B,EAAwC;AACtCC,QAAAA,KAAK,EAAE1C;AAD+B,OAAxC;AAGD;;;8BAEgBkB,S,EAAmBE,O,EAAmCuB,U,EAAuB;AAC5F,UAAMC,OAAO,GAAG5B,IAAI,CAAC6B,SAAL,CAAe;AAC7B3B,QAAAA,SAAS,EAATA,SAD6B;AAE7BE,QAAAA,OAAO,EAAPA,OAF6B;AAG7BuB,QAAAA,UAAU,EAAVA;AAH6B,OAAf,CAAhB,CAD4F,CAO5F;;AACA,UAAIC,OAAO,CAACE,MAAR,GAAiB,KAArB,EAA4B;AAC1B,cAAM,IAAIC,KAAJ,CAAU,wFAAV,CAAN;AACD,OAV2F,CAY5F;;;AACA,UAAI,CAAC,KAAKvB,iBAAN,IAA2B,CAAC,KAAKtC,EAArC,EAAyC;AACvC,cAAM,IAAI6D,KAAJ,CAAU,8FAAV,CAAN;AACD,OAf2F,CAiB5F;;;AACA,UAAI,CAAC,KAAKtB,WAAV,EAAuB;AACrB,aAAKO,YAAL,CAAkBpC,IAAlB,CAAuBgD,OAAvB;AACA;AACD;;AAED,WAAK1D,EAAL,CAAQ+C,IAAR,CAAaW,OAAb;AACD;;;iCAEmB;AAClB,UAAI,KAAK1D,EAAT,EAAa,KAAKA,EAAL,CAAQ8D,KAAR;AACb,WAAK9D,EAAL,GAAU,IAAV;AACD;;;;;;AAGI,IAAM+D,QAAQ,GAAG,IAAIvE,QAAJ,EAAjB","sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport Sockette from 'sockette';\nimport axios from 'axios';\n\nconst unsafeGlobal: any = global;\nunsafeGlobal.WebSocket = require('isomorphic-ws');\n\ninterface DispatchConfigurationInput {\n  shardName?: string | null;\n  maxConnectionsPerShard?: number;\n  authorization?: string;\n}\n\ninterface DispatchOptions {\n  projectId?: string;\n  shardName?: string | null;\n  maxConnectionsPerShard?: number;\n  authorization?: string;\n  [index: string]: any;\n}\n\nexport enum PlatformEvents {\n  CONNECTED = '@@KOJI_DISPATCH/CONNECTED',\n  CONNECTED_CLIENTS_CHANGED = '@@KOJI_DISPATCH/CONNECTED_CLIENTS_CHANGED',\n  IDENTIFY = '@@KOJI_DISPATCH/IDENTIFY',\n  SET_USER_INFO = '@@KOJI_DISPATCH/SET_USER_INFO',\n}\n\nexport interface MessageHandler {\n  id: string;\n  eventName: string;\n  callback: MessageHandlerCallback;\n}\n\nexport type MessageHandlerCallback = (payload: { [index: string]: any }, metadata: { latencyMs?: number }) => void;\n\nexport interface ShardInfo {\n  shardName: string;\n  numConnectedClients: number;\n}\n\nexport interface ConnectionInfo {\n  clientId?: string;\n  shardName: string;\n}\n\nexport class Dispatch {\n  private authToken?: string;\n  private projectId?: string;\n\n  private initialConnection: boolean = false;\n  private isConnected: boolean = false;\n  private eventHandlers: MessageHandler[] = [];\n  private messageQueue: string[] = [];\n  private ws: Sockette | null = null;\n\n  public async info(): Promise<ShardInfo[]> {\n    const { data } = await axios.get(`https://dispatch-info.api.gokoji.com/info/${this.projectId}`);\n    return (data || [])[0];\n  }\n\n  public setProjectId(projectId: string) {\n    this.projectId = projectId;\n  }\n\n  public async connect(config: DispatchConfigurationInput = {}): Promise<ConnectionInfo> {\n    return new Promise((resolve) => {\n      if (this.ws) {\n        return;\n      }\n\n      const options: DispatchOptions = {\n        projectId: this.projectId,\n        shardName: config.shardName,\n        maxConnectionsPerShard: config.maxConnectionsPerShard || 100,\n      };\n\n      const params: string[] = Object.keys(options).reduce((acc: string[], cur) => {\n        if (options[cur]) {\n          acc.push(`${cur}=${encodeURIComponent(options[cur])}`);\n        }\n        return acc;\n      }, []);\n\n      const url = `wss://dispatch.api.gokoji.com?${params.join('&')}`;\n\n      this.authToken = config.authorization;\n\n      // Create a socket connection to the dispatch server\n      this.ws = new Sockette(url, {\n        timeout: 5e3,\n        maxAttempts: 10,\n        onmessage: (e) => this.handleMessage(e, resolve),\n        onreconnect: () => this.handleReconnect(),\n        onmaximum: () => this.handleMaximum(),\n        onclose: (e) => this.handleClose(e),\n        onerror: (e) => this.handleError(e),\n      });\n    });\n  }\n\n  private handleMessage({ data }: { data: string }, resolve: Function) {\n    const { eventName, latencyMs, payload } = JSON.parse(data || '{}');\n    console.log('message', data);\n\n    if (eventName === PlatformEvents.CONNECTED) {\n      this.initialConnection = true;\n      this.isConnected = true;\n      if (this.authToken) this.identify(this.authToken);\n      resolve({\n        clientId: payload.clientId,\n        shardName: payload.shardName,\n      });\n      return;\n    }\n\n    this.eventHandlers.forEach((handler) => {\n      if (eventName === handler.eventName) {\n        handler.callback(payload, { latencyMs });\n      }\n    });\n  }\n\n  private handleReconnect() {\n    console.log('reconnect');\n    this.isConnected = true;\n    this.messageQueue = this.messageQueue.reduce((acc, cur) => {\n      if (this.ws) {\n        this.ws.send(cur);\n      }\n      return acc;\n    }, []);\n  }\n\n  private handleMaximum() {}\n\n  private handleClose(e: Event) {\n    console.log('close', e);\n    this.isConnected = false;\n  }\n\n  private handleError(e: Event) {\n    console.error('[Koji Dispatch] error', e);\n  }\n\n  public on(eventName: string, callback: MessageHandlerCallback): Function {\n    const handlerId = uuidv4();\n\n    this.eventHandlers.push({\n      id: handlerId,\n      eventName,\n      callback,\n    });\n\n    return () => {\n      this.eventHandlers = this.eventHandlers.filter(({ id }) => id !== handlerId);\n    };\n  }\n\n  public setUserInfo(userInfo: { [index: string]: any }) {\n    this.emitEvent(PlatformEvents.SET_USER_INFO, userInfo);\n  }\n\n  public identify(authToken: string) {\n    this.emitEvent(PlatformEvents.IDENTIFY, {\n      token: authToken,\n    });\n  }\n\n  public emitEvent(eventName: string, payload: { [index: string]: any }, recipients?: string[]) {\n    const message = JSON.stringify({\n      eventName,\n      payload,\n      recipients,\n    });\n\n    // Discard a long message\n    if (message.length > 128e3) {\n      throw new Error('Message is too long to be sent through Koji Dispatch. Messages must be less than 128kb');\n    }\n\n    // Check instantiation\n    if (!this.initialConnection || !this.ws) {\n      throw new Error('Please make sure you have called and awaited `connect()` before attempting to send a message');\n    }\n\n    // If the connection has dropped, push the message into a queue\n    if (!this.isConnected) {\n      this.messageQueue.push(message);\n      return;\n    }\n\n    this.ws.send(message);\n  }\n\n  public disconnect() {\n    if (this.ws) this.ws.close();\n    this.ws = null;\n  }\n}\n\nexport const dispatch = new Dispatch();\n"],"file":"index.js"}